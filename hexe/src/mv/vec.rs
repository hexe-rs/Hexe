//! An inline vector of moves.

use super::*;
use uncon::*;
use std::borrow::{Borrow, BorrowMut};
use std::cmp;
use std::mem;
use std::ops;
use std::u8;

const VEC_CAP: usize = u8::MAX as usize;

/// An inline vector of moves generated by a `Position`.
///
/// There is no known case where there have been more than 255 moves for a legal
/// position. Because of this, performing an allocation for a list of generated
/// moves is an avoidable waste of time.
pub struct MoveVec {
    /// The internal inline buffer. Uses u16 for convenience.
    buf: [u16; VEC_CAP],
    /// The vector's length.
    len: u8,
}

impl PartialEq for MoveVec {
    #[inline]
    fn eq(&self, other: &MoveVec) -> bool {
        if self as *const _ == other as *const _ {
            return true;
        }
        self.len == other.len && self.buf[..] == other.buf[..]
    }
}

impl Eq for MoveVec {}

impl Clone for MoveVec {
    #[inline]
    fn clone(&self) -> MoveVec {
        MoveVec { buf: self.buf, len: self.len }
    }
}

impl Default for MoveVec {
    #[inline]
    fn default() -> Self {
        MoveVec {
            buf: unsafe { mem::uninitialized() },
            len: 0,
        }
    }
}

impl AsRef<[Move]> for MoveVec {
    #[inline]
    fn as_ref(&self) -> &[Move] { self }
}

impl AsMut<[Move]> for MoveVec {
    #[inline]
    fn as_mut(&mut self) -> &mut [Move] { self }
}

impl Borrow<[Move]> for MoveVec {
    #[inline]
    fn borrow(&self) -> &[Move] { self }
}

impl BorrowMut<[Move]> for MoveVec {
    #[inline]
    fn borrow_mut(&mut self) -> &mut [Move] { self }
}

impl ops::Deref for MoveVec {
    type Target = [Move];

    #[inline]
    fn deref(&self) -> &[Move] {
        let slice = &self.buf[..(self.len as usize)];
        unsafe { slice.into_unchecked() }
    }
}

impl ops::DerefMut for MoveVec {
    #[inline]
    fn deref_mut(&mut self) -> &mut [Move] {
        let slice = &mut self.buf[..(self.len as usize)];
        unsafe { slice.into_unchecked() }
    }
}

impl MoveVec {
    /// Creates a new empty vector.
    #[inline]
    pub fn new() -> MoveVec {
        MoveVec::default()
    }

    /// Creates a new vector with a move repeated `num` times.
    ///
    /// If `num` is greater than the max possible length, the max length will be
    /// used.
    ///
    /// This is analogous to `vec![mv; num]` but for `MoveVec`.
    #[inline]
    pub fn from_elem(mv: Move, num: usize) -> MoveVec {
        MoveVec::from_init(num, |_| mv)
    }

    /// Creates a new `MoveVec` by instantiating each slot with the provided
    /// initializer.
    ///
    /// If `len` is greater than the max possible length, the max length will be
    /// used.
    ///
    /// # Examples
    ///
    /// ```
    /// # use hexe::mv::*;
    /// # use hexe::prelude::*;
    /// # use hexe::core::piece::*;
    /// fn random() -> Move {
    ///     # Move::new(Square::A1, Square::A2, Promotion::Queen, MoveKind::Normal)
    ///     /* ... */
    /// }
    ///
    /// // Generate 50 random moves
    /// let vec = MoveVec::from_init(50, |_| random());
    /// ```
    #[inline]
    pub fn from_init<F: FnMut(usize) -> Move>(len: usize, mut init: F) -> MoveVec {
        let mut vec = MoveVec::new();
        vec.len = cmp::min(len, VEC_CAP) as u8;
        for (i, m) in vec.iter_mut().enumerate() {
            *m = init(i);
        }
        vec
    }

    /// Removes all values from the vector.
    #[inline]
    pub fn clear(&mut self) {
        self.len = 0
    }

    /// Pushes a new move onto the end of the vector, or returns it if full.
    #[inline]
    pub fn push(&mut self, mv: Move) -> Option<Move> {
        if self.len == u8::MAX {
            Some(mv)
        } else {
            self.buf[self.len as usize] = mv.0;
            self.len += 1;
            None
        }
    }

    /// Pushes a new move onto the end of the vector. Swaps out the last move
    /// and returns it if full.
    #[inline]
    pub fn push_swap(&mut self, mv: Move) -> Option<Move> {
        self.push(mv).map(|mv| {
            Move(mem::replace(&mut self.buf[VEC_CAP - 1], mv.0))
        })
    }

    /// Pushes a new move onto the end of the vector without checking whether
    /// it is full.
    #[inline]
    pub unsafe fn push_unchecked(&mut self, mv: Move) {
        *self.buf.get_unchecked_mut(self.len as usize) = mv.0;
        self.len = self.len.wrapping_add(1);
    }

    /// Extends `self` with as many moves as it can fit.
    ///
    /// Moves that don't fit are returned as a slice of the original.
    pub fn extend_from_slice<'a>(&mut self, moves: &'a [Move]) -> &'a [Move] {
        let rem: &mut [Move] = unsafe {
            (&mut self.buf[(self.len as usize)..]).into_unchecked()
        };
        if moves.len() > rem.len() {
            self.len = VEC_CAP as _;
            let (chunk, rest) = moves.split_at(rem.len());
            rem.copy_from_slice(chunk);
            rest
        } else {
            self.len += moves.len() as u8;
            rem[..moves.len()].copy_from_slice(moves);
            Default::default()
        }
    }

    /// Pops the last move from the end of the vector and returns it.
    #[inline]
    pub fn pop(&mut self) -> Option<Move> {
        if self.len == 0 { None } else {
            self.len -= 1;
            Some(Move(self.buf[self.len as usize]))
        }
    }

    /// Shortens the vector, keeping the first `len` moves.
    ///
    /// If `len` is greater than the current length, this has no effect.
    #[inline]
    pub fn truncate(&mut self, len: usize) {
        if len < (self.len as usize) {
            self.len = len as u8;
        }
    }

    /// Sets the length of the vector.
    ///
    /// If `len` is greater than the max possible length, the max length will be
    /// used.
    ///
    /// # Safety
    ///
    /// Although it is perfectly safe to shrink the vector this way, one should
    /// use [`truncate`](#method.truncate) instead.
    ///
    /// If used to grow the vector, moves past the previous length need to be
    /// initialized.
    #[inline]
    pub unsafe fn set_len(&mut self, len: usize) {
        self.len = cmp::min(len, VEC_CAP) as u8;
    }
}
